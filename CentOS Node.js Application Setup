https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-centos-7
____________________________________________________________________________________________________________________
_________How To Set Up a Node.js Application for Production on CentOS 7__________________________________________
____________________________________________________________________________________________________________________

Node.js is an open source Javascript runtime environment for easily building server-side and networking applications. The platform runs on Linux, OS X, FreeBSD, and Windows, and its applications are written in JavaScript. Node.js applications can be run at the command line but we will teach you how to run them as a service, so they automatically restart on reboot or failure, so you can use them in a production environment.

In this tutorial, we will cover setting up a production-ready Node.js environment that is composed of two CentOS 7 servers; one server will run Node.js applications managed by PM2, while the other will provide users with access to the application through an Nginx reverse proxy to the application server.

____________________________________________________________________________________________________________________
_________Prereq's__________________________________________________________________________________________________
____________________________________________________________________________________________________________________

This guide uses two CentOS 7 servers with private networking (in the same datacenter). Private networking can be configured on new servers when they are being created (in the "Select additional options" section). We will refer to them by the following names:

app: The server where we will install Node.js runtime, your Node.js application, and PM2.

web: The server where we will install the Nginx web server, which will act as a reverse proxy to your application. Users will accesss this server's public IP address to get to your Node.js application.

____________________________________________________________________________________________________________________
Note: Refer to the "Digital Ocean Documentation - How to Enable Private Networking on Droplet" (https://www.digitalocean.com/docs/networking/private-networking/how-to/enable/) if you intend on using an existing server that doesn't currently have private networking configured.
____________________________________________________________________________________________________________________

Before you begin this guide, you should have a regular, non-root user with "sudo" privileges configured on both of your servers--this is the user that you should log in to your server as. You can learn how to configure a regular user account by following our "initial server setup guide for CentOS 7" (https://www.digitalocean.com/community/tutorials/initial-server-setup-with-centos-7).
____________________________________________________________________________________________________________________

It is possible to use a single server for this tutorial, but you will have to make a few changes along the way. Simply use the localhost IP address, i.e. "127.0.0.1", wherever the app server's private IP address is used.
____________________________________________________________________________________________________________________

Here is a digram of what your setup will be after following this tutorial:

[User] ----> http://example.com ----> [Web Server (Reverse Proxy)] ---- Private IP ----> [App Server - Node.js Application (Private Network)]

____________________________________________________________________________________________________________________

If you want to be able to access your web server via a domain name, instead of its public IP address, purchase a domain name then follow these tutorials:

"How To Set Up A Host Name with DigitalOcean" (https://www.digitalocean.com/community/tutorials/how-to-set-up-a-host-name-with-digitalocean)
"How to Point to DigitalOcean Nameservers From Common Domain Registrars" (How to Point to DigitalOcean Nameservers From Common Domain Registrars)
____________________________________________________________________________________________________________________

Let's get started by installing the Node.js runtime on the app server.

____________________________________________________________________________________________________________________
___________Step 1 - Installing Node.js______________________________________________________________________________
____________________________________________________________________________________________________________________

We will install the latest LTS release of Node.js, on the app server.

SSH to your app server using the regular, non-root user with "sudo" privileges.

On the app server, let's use "curl" to download the "NodeSource" (https://github.com/nodesource/distributions) RPM Repository configuration file:

$ curl -L -o nodesource_setup.sh https://rpm.nodesource.com/setup_10.x

"CURL" will use the HTTPS protocol to download the setup script to your server, with the output including information relevant to the download:

[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ curl -L -o nodesource_setup.sh https://rpm.nodesource.com/setup_10.x
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 12100  100 12100    0     0   181k      0 --:--:-- --:--:-- --:--:--  181k
[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ 
____________________________________________________________________________________________________________________

Next, you should inspect the script's contents. The following command will open the NodeSource setup script in your servers console, which you can then cross-reference with the "NodeSource setup script"  (https://raw.githubusercontent.com/nodesource/distributions/master/rpm/setup_10.x) (from the NodeSource Distributions Github repository) to confirm that the script downloaded properly.

$ vi nodesource_setup.sh

Once satisfied with the file, exit "vi" by typing ":q" to "quit" and return to the command line.

Now let's run the setup script to install the NodeSource RPM Repository. This will enable us to access NodeSource's repository from within the "yum" package manager:

$ sudo -E bash nodesource_setup.sh

Before installing Node.js it is important to clean all the cached information from "yum". Cleaning the cache will ensure that yum uses the network connection to get Node.js from our new NodeSource Repository (which will prevent any potential conflicts caused by outdated packages):

$ sudo yum clean all

Next we will download and make usable all the metadata for the currently enabled yum repos. This will ensure that our yum queries are completed as quickly as possible:

$ sudo yum makecache fast

To compile and install native add-ons from "npm" we also need to install build tools:

$ sudo yum install -y gcc-c++ make

Now we can install the lastest release of the Node.js package:

$ sudo yum install -y nodejs

Verify that Node is installed by checking its version with this command:

$ sudo node -v

[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ sudo node -v
v10.20.1

The Node.js runtime is now installed, and ready to run an application. Let's write a Node.js application.

____________________________________________________________________________________________________________________
___________Step 2 - Creating the Node.js Application_______________________________________________________________
____________________________________________________________________________________________________________________

Now we will create a Hello World application that simply returns "Hello World" to any HTTP requests. This is a sample application that will help you get Node.js set up, which you can replace with your own application--just make sure that you modify your application to listen on the appropriate IP addresses and ports.

Because we want our Node.js application to serve requests that come from our reverse proxy server (web) we will use our app server's private network interface for inter-server communication. Look up your app server's private network address.

If you are using a DigitalOcean Droplet as your server, you may look up the server's private IP address through the Metadata service. On the app server, use the curl command to retrive the IP address now:

$ curl -sw "\n" http://169.254.169.254/metadata/v1/interfaces/private/0/ipv4/address

You will want to copy the output (the private IP address), as it will be used to configure the Node.js application.

Next, create and open your Node.js application for editing. For this tutorial, we will use "vi" to edit a sample application called "hello.js":

$ vi hello.js

Insert the following code into the file, and be sure to substitute the app server's private IP address for both fo the highlighted "APP_PRIVATE_IP_ADDRESS" items. If you want to, you may also replace the highlighted port, "8080", in both locations (be sure to use a non-admin port, i.e. "1024" or greater):

 127.0.0.1
____________________________________________________________________________________________________________________
                                            hello.js
____________________________________________________________________________________________________________________
var http = require('http');
http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(8080, '127.0.0.1');
console.log('Server running at http://127.0.0.1:8080/');
____________________________________________________________________________________________________________________

This Node.js application simply listens on the specified IP address and port, and returns "Hello World" with a 200 HTTP success code. This means that the application is only reachable from servers on the same private network, such as our web server.

If you want to test if your application works, run this "node" command on the app server:

$ node hello.js

____________________________________________________________________________________________________________________
Note: Running a Node.js application in this manner will block additional commands until the application is killed by pressing "CTRL+C".
____________________________________________________________________________________________________________________

It will save a lot of Nginx debugging if we first test that our web server is able to communicate with the Node.js application on app.

In order to test the application, open another terminal session and connect to your web server. Because the web server is on the same private network, it should be able to reach the private IP address of the app server using "curl". Be sure to substitute in the app server's private IP address for APP_PRIVATE_IP_ADDRESS, and the port if you changed it

$ curl http://APP_PRVIATE_IP_ADDRESS:8080

If you see the following output, the application is working properly and listening on the proper IP address and port.

Node Application Output
Hello World

[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ curl http://127.0.0.1:8080/
Hello World
[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ 

If you do not see the proper output, make sure that your Node.js application is running, and configured to listen on the proper IP address and port.

On the app server, be sure to kill the application by pressing "CTRL+C"

____________________________________________________________________________________________________________________
___________Step 3 - Installing and Using PM2_______________________________________________________________
____________________________________________________________________________________________________________________

Now we will isntall PM2, which is a process manager for Node.js applications. PM2 provides an easy way to manage and daemonize applications (run them as a service).

We will use Node Packaged Modules (NPM), which is basically a package manager for Node modules that installs with Node.js, to install PM2 on our app server. Use this command to install PM2:

$ sudo npm install pm2@latest -g

We will cover a few basic uses of PM2.

The first thing you want to do is to use the pm2 start command to run the application, hello.js, in the background:

$ pm2 start hello.js

This also adds your application to PM2's process list, which is outputted every time you start an application:

Output
┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────────────┬──────────┐
│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ memory      │ watching │
├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────────────┼──────────┤
│ hello    │ 0  │ fork │ 30099 │ online │ 0       │ 0s     │ 14.227 MB   │ disabled │
└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────────────┴──────────┘

[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ pm2 start hello.js

                        -------------

__/\\\\\\\\\\\\\____/\\\\____________/\\\\____/\\\\\\\\\_____
 _\/\\\/////////\\\_\/\\\\\\________/\\\\\\__/\\\///////\\\___
  _\/\\\_______\/\\\_\/\\\//\\\____/\\\//\\\_\///______\//\\\__
   _\/\\\\\\\\\\\\\/__\/\\\\///\\\/\\\/_\/\\\___________/\\\/___
    _\/\\\/////////____\/\\\__\///\\\/___\/\\\________/\\\//_____
     _\/\\\_____________\/\\\____\///_____\/\\\_____/\\\//________
      _\/\\\_____________\/\\\_____________\/\\\___/\\\/___________
       _\/\\\_____________\/\\\_____________\/\\\__/\\\\\\\\\\\\\\\_
        _\///______________\///______________\///__\///////////////__


                          Runtime Edition

        PM2 is a Production Process Manager for Node.js applications
                     with a built-in Load Balancer.

                Start and Daemonize any application:
                $ pm2 start app.js

                Load Balance 4 instances of api.js:
                $ pm2 start api.js -i 4

                Monitor in production:
                $ pm2 monitor

                Make pm2 auto-boot at server restart:
                $ pm2 startup

                To go further checkout:
                http://pm2.io/


                        -------------

[PM2] Spawning PM2 daemon with pm2_home=/home/eugene/.pm2
[PM2] PM2 Successfully daemonized
[PM2] Starting /home/eugene/hello.js in fork_mode (1 instance)
[PM2] Done.
┌─────┬──────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id  │ name     │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├─────┼──────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ 0   │ hello    │ default     │ N/A     │ fork    │ 15840    │ 0s     │ 0    │ online    │ 0%       │ 25.8mb   │ eugene   │ disabled │
└─────┴──────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘
[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ 

As you can see, PM2 automatically assigns an App name (based on the filename, without the ".js" extension) and a PM2 id. PM2 also maintains other information, such as the PID of the process, its current status, and memory usage.

Applications that are running under PM2 will be restarted automatically if the application crashes or is killed, but an additional step needs to be taken to get the application to launch on system startup (boot or reboot). Luckily, PM2 provides an easy way to do this, the "startup" subcommand.

The "startup" subcommand generates and configures a startup script to launch PM2 and its managed processes on servert boots. You must also specify the init system you are running on, which is systemd, in our case:

$ sudo pm2 startup systemd

Output
[PM2] Generating system init script in /etc/systemd/system/pm2.service
[PM2] Making script booting at startup...
[PM2] -systemd- Using the command:
      su root -c "pm2 dump && pm2 kill" && su root -c "systemctl daemon-reload && systemctl enable pm2 && systemctl start pm2"
[PM2] Dumping processes
[PM2] Stopping PM2...
[PM2] All processes have been stopped and deleted
[PM2] PM2 stopped
[PM2] Done.


[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ sudo pm2 startup systemd
[sudo] password for eugene: 

                        -------------

__/\\\\\\\\\\\\\____/\\\\____________/\\\\____/\\\\\\\\\_____
 _\/\\\/////////\\\_\/\\\\\\________/\\\\\\__/\\\///////\\\___
  _\/\\\_______\/\\\_\/\\\//\\\____/\\\//\\\_\///______\//\\\__
   _\/\\\\\\\\\\\\\/__\/\\\\///\\\/\\\/_\/\\\___________/\\\/___
    _\/\\\/////////____\/\\\__\///\\\/___\/\\\________/\\\//_____
     _\/\\\_____________\/\\\____\///_____\/\\\_____/\\\//________
      _\/\\\_____________\/\\\_____________\/\\\___/\\\/___________
       _\/\\\_____________\/\\\_____________\/\\\__/\\\\\\\\\\\\\\\_
        _\///______________\///______________\///__\///////////////__


                          Runtime Edition

        PM2 is a Production Process Manager for Node.js applications
                     with a built-in Load Balancer.

                Start and Daemonize any application:
                $ pm2 start app.js

                Load Balance 4 instances of api.js:
                $ pm2 start api.js -i 4

                Monitor in production:
                $ pm2 monitor

                Make pm2 auto-boot at server restart:
                $ pm2 startup

                To go further checkout:
                http://pm2.io/


                        -------------

[PM2] Init System found: systemd
Platform systemd
Template
[Unit]
Description=PM2 process manager
Documentation=https://pm2.keymetrics.io/
After=network.target

[Service]
Type=forking
User=root
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
Environment=PATH=/sbin:/bin:/usr/sbin:/usr/bin:/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
Environment=PM2_HOME=/root/.pm2
PIDFile=/root/.pm2/pm2.pid
Restart=on-failure

ExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrect
ExecReload=/usr/lib/node_modules/pm2/bin/pm2 reload all
ExecStop=/usr/lib/node_modules/pm2/bin/pm2 kill

[Install]
WantedBy=multi-user.target

Target path
/etc/systemd/system/pm2-root.service
Command list
[ 'systemctl enable pm2-root' ]
[PM2] Writing init configuration in /etc/systemd/system/pm2-root.service
[PM2] Making script booting at startup...
[PM2] [-] Executing: systemctl enable pm2-root...
Created symlink /etc/systemd/system/multi-user.target.wants/pm2-root.service → /etc/systemd/system/pm2-root.service.
[PM2] [v] Command successfully executed.
+---------------------------------------+
[PM2] Freeze a process list on reboot via:
$ pm2 save

[PM2] Remove init script via:
$ pm2 unstartup systemd
[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ 

To ensure PM2 knows which applications to start on boot, we need to save the current process list. To save the list:

$ pm2 save

You will see output like the following, which indicates that the PM2 process list has been saved:

Output
[PM2] Saving current process list...
[PM2] Successfully saved in /home/deployer/.pm2/dump.pm2

[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ pm2 save
[PM2] Saving current process list...
[PM2] Successfully saved in /home/eugene/.pm2/dump.pm2
[eugene@centos-s-1vcpu-1gb-sfo2-01 ~]$ 

Now your PM2-managed applications should start automatically on boot.

PM2 provides many subcommands that allow you to manage or look up information about your applications. Note that running "pm2" without any arguments will display a help page, including example usage, that covers PM2 usage in more detail than this section of the tutorial.

Stop an application with this command (specify the PM2 "App name" or "id"):

$ pm2 stop example

Restart an application with this command (specify the PM2 "App name" or "id"):

$ pm2 restart example

The list of applications currently manged by PM2 can also be looked up with the "list" subcommand:

$ pm2 list

More information about a specific application can be found by using the "info" subcommand (specify the PM2 App name or id):

$ pm2 info example

The PM2 process monitor can be pulled up with the "monit" subcommand. This display sthe application status, CPU, and memory usage:

$ pm2 monit

____________________________________________________________________________________________________________________
Note: Running PM2's "monit" command will block additional commands until the application is killed by pressing "CRTL+C".
____________________________________________________________________________________________________________________

Now that your Node.js application is running, and managed by PM2, let's set up the reverse proxy.

____________________________________________________________________________________________________________________
___________Step 4 - Setting Up and Nginx Reverse Proxy Server_______________________________________________________
____________________________________________________________________________________________________________________
